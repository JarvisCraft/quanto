// parser grammar qasm3Parser;

program = _{ SOI ~ version? ~ statementOrScope* ~ EOI }
version =  { OPENQASM ~ VersionSpecifier ~ SEMICOLON }

// A statement is any valid single statement of an OpenQASM 3 program, with the
// exception of the version-definition statement (which must be unique, and the
// first statement of the file if present).  This file just defines rules for
// parsing; we leave semantic analysis and rejection of invalid scopes for
// compiler implementations.

statement = {
    pragma
  | annotation* ~ anyStatement
}
// All the actual statements of the language.
anyStatement = {
    aliasDeclarationStatement
  | assignmentStatement
  | barrierStatement
  | boxStatement
  | breakStatement
  | calStatement
  | calibrationGrammarStatement
  | classicalDeclarationStatement
  | constDeclarationStatement
  | continueStatement
  | defStatement
  | defcalStatement
  | delayStatement
  | endStatement
  | expressionStatement
  | externStatement
  | forStatement
  | gateCallStatement
  | gateStatement
  | ifStatement
  | includeStatement
  | ioDeclarationStatement
  | measureArrowAssignmentStatement
  | oldStyleDeclarationStatement
  | quantumDeclarationStatement
  | resetStatement
  | returnStatement
  | switchStatement
  | whileStatement
}

annotation = { AnnotationKeyword ~ RemainingLineContent? }
scope      = { LBRACE ~ statementOrScope* ~ RBRACE }
pragma     = { PRAGMA ~ RemainingLineContent }

statementOrScope = { statement | scope }

/* Start top-level statement definitions. */

// Inclusion statements.
calibrationGrammarStatement = { DEFCALGRAMMAR ~ StringLiteral ~ SEMICOLON }
includeStatement            = { INCLUDE ~ StringLiteral ~ SEMICOLON }

// Control-flow statements.
breakStatement    = { BREAK ~ SEMICOLON }
continueStatement = { CONTINUE ~ SEMICOLON }
endStatement      = { END ~ SEMICOLON }
forStatement      = { FOR ~ scalarType ~ Identifier ~ IN ~ (setExpression | LBRACKET ~ rangeExpression ~ RBRACKET | expression) ~ statementOrScope }
ifStatement       = { IF ~ LPAREN ~ expression ~ RPAREN ~ statementOrScope ~ (ELSE ~ statementOrScope)? }
returnStatement   = { RETURN ~ (expression | measureExpression)? ~ SEMICOLON }
whileStatement    = { WHILE ~ LPAREN ~ expression ~ RPAREN ~ statementOrScope }
switchStatement   = { SWITCH ~ LPAREN ~ expression ~ RPAREN ~ LBRACE ~ switchCaseItem* ~ RBRACE }
switchCaseItem    = {
    CASE ~ expressionList ~ scope
  | DEFAULT ~ scope
}

// Quantum directive statements.

barrierStatement = { BARRIER ~ gateOperandList? ~ SEMICOLON }
boxStatement     = { BOX ~ designator? ~ scope }

delayStatement = { DELAY ~ designator ~ gateOperandList? ~ SEMICOLON }

/*
    `gateCallStatement`  is split in two to avoid a potential ambiguity with an
    * `expressionStatement` that consists of a single function call.  The only
    * "gate" that can have no operands is `gphase` with no control modifiers, and
    * `gphase(pi);` looks grammatically identical to `fn(pi);`.  We disambiguate by
    * having `gphase` be its own token, and requiring that all other gate calls
    * grammatically have at least one qubit.  Strictly, as long as `gphase` is a
    * separate token, ANTLR can disambiguate the statements by the definition
    * order, but this is more robust.
*/

gateCallStatement = {
    gateModifier* ~ Identifier ~ (LPAREN ~ expressionList? ~ RPAREN)? ~ designator? ~ gateOperandList ~ SEMICOLON
  | gateModifier* ~ GPHASE ~ (LPAREN ~ expressionList? ~ RPAREN)? ~ designator? ~ gateOperandList? ~ SEMICOLON
}
// measureArrowAssignmentStatement also permits the case of not assigning the
// result to any classical value too.
measureArrowAssignmentStatement = { measureExpression ~ (ARROW ~ indexedIdentifier)? ~ SEMICOLON }
resetStatement                  = { RESET ~ gateOperand ~ SEMICOLON }

// Primitive declaration statements.
aliasDeclarationStatement     = { LET ~ Identifier ~ EQUALS ~ aliasExpression ~ SEMICOLON }
classicalDeclarationStatement = { (scalarType | arrayType) ~ Identifier ~ (EQUALS ~ declarationExpression)? ~ SEMICOLON }
constDeclarationStatement     = { CONST ~ scalarType ~ Identifier ~ EQUALS ~ declarationExpression ~ SEMICOLON }
ioDeclarationStatement        = { (INPUT | OUTPUT) ~ (scalarType | arrayType) ~ Identifier ~ SEMICOLON }
oldStyleDeclarationStatement  = { (CREG | QREG) ~ Identifier ~ designator? ~ SEMICOLON }
quantumDeclarationStatement   = { qubitType ~ Identifier ~ SEMICOLON }

// Declarations and definitions of higher-order objects.
defStatement    = { DEF ~ Identifier ~ LPAREN ~ argumentDefinitionList? ~ RPAREN ~ returnSignature? ~ scope }
externStatement = { EXTERN ~ Identifier ~ LPAREN ~ externArgumentList? ~ RPAREN ~ returnSignature? ~ SEMICOLON }
gateStatement   = { GATE ~ Identifier ~ (LPAREN ~ identifierList? ~ RPAREN)? ~ identifierList ~ scope }

// Non-declaration assignments and calculations.
assignmentStatement = { indexedIdentifier ~ (EQUALS | CompoundAssignmentOperator) ~ (expression | measureExpression) ~ SEMICOLON }
expressionStatement = { expression ~ SEMICOLON }

// Statements where the bulk is in the calibration language.
calStatement    = { CAL ~ LBRACE ~ CalibrationBlock? ~ RBRACE }
defcalStatement = { DEFCAL ~ defcalTarget ~ (LPAREN ~ defcalArgumentDefinitionList? ~ RPAREN)? ~ defcalOperandList ~ returnSignature? ~ LBRACE ~ CalibrationBlock? ~ RBRACE }

/* End top-level statement definitions. */

/* Start expression definitions. */
expression = {
    expr_prefix? ~ expr_primary ~ expr_postfix? ~ (expr_infix ~ expr_prefix? ~ expr_primary ~ expr_postfix?)*
}

expr_prefix = _{ TILDE | EXCLAMATION_POINT | MINUS }
// FIXME, should be like { expr_cast ~ LPAREN ~ expr ~ RPAREN }

expr_infix = {
    expr_multiplicative
  | expr_additive
  | expr_bitshift
  | expr_comparison
  | expr_equality
  | expr_power
  | expr_bitwise_and
  | expr_bitwise_xor
  | expr_bitwise_or
  | expr_logical_and
  | expr_logical_or
}

expr_multiplicative = { ASTERISK | SLASH | PERCENT }
expr_additive       = { PLUS | MINUS }
expr_bitshift       = { BitshiftOperator }
expr_comparison     = { ComparisonOperator }
expr_equality       = { EqualityOperator }
expr_power          = { DOUBLE_ASTERISK }
expr_bitwise_and    = { AMPERSAND }
expr_bitwise_xor    = { CARET }
expr_bitwise_or     = { PIPE }
expr_logical_and    = { DOUBLE_AMPERSAND }
expr_logical_or     = { DOUBLE_PIPE }

expr_postfix = { indexOperator }

expr_primary    = _{ expr_literal | (expr_cast | expr_durationof | expr_call)? ~ LPAREN ~ expression ~ RPAREN }
expr_literal    =  {
    Identifier
  | BinaryIntegerLiteral
  | OctalIntegerLiteral
  | DecimalIntegerLiteral
  | HexIntegerLiteral
  | FloatLiteral
  | ImaginaryLiteral
  | BooleanLiteral
  | BitstringLiteral
  | TimingLiteral
  | HardwareQubit
  | QuantoVar
}
expr_cast       =  { scalarType | arrayType }
expr_durationof =  { DURATIONOF }
expr_call       =  { Identifier }

// Special-case expressions that are only valid in certain contexts.  These are
// not in the expression tree, but can contain elements that are within it.
aliasExpression       = { expression ~ (DOUBLE_PLUS ~ expression)* }
declarationExpression = { arrayLiteral | expression | measureExpression }
measureExpression     = { MEASURE ~ gateOperand }
rangeExpression       = { expression? ~ COLON ~ expression? ~ (COLON ~ expression)? }
setExpression         = { LBRACE ~ expression ~ (COMMA ~ expression)* ~ COMMA? ~ RBRACE }
arrayLiteral          = { LBRACE ~ (expression | arrayLiteral) ~ (COMMA ~ (expression | arrayLiteral))* ~ COMMA? ~ RBRACE }

// The general form is a comma-separated list of indexing entities.
// `setExpression` is only valid when being used as a single index = registers
// can support it for creating aliases, but arrays cannot.
indexOperator = {
    LBRACKET ~ (setExpression | (expression | rangeExpression) ~ (COMMA ~ (expression | rangeExpression))* ~ COMMA?) ~ RBRACKET
}

// Alternative form to `indexExpression` for cases where an obvious l-value is
// better grammatically than a generic expression.  Some current uses of this
// rule may be better as `expression`, leaving the semantic analysis to later
// (for example in gate calls).
indexedIdentifier = { Identifier ~ indexOperator* }

/* End expression definitions. */

/* Start type definitions. */

returnSignature = { ARROW ~ scalarType }
gateModifier    = {
    (INV | POW ~ LPAREN ~ expression ~ RPAREN | (CTRL | NEGCTRL) ~ (LPAREN ~ expression ~ RPAREN)?) ~ AT
}

scalarType         = {
    BIT ~ designator?
  | INT ~ designator?
  | UINT ~ designator?
  | FLOAT ~ designator?
  | ANGLE ~ designator?
  | BOOL
  | DURATION
  | STRETCH
  | COMPLEX ~ (LBRACKET ~ scalarType ~ RBRACKET)?
}
qubitType          = { QUBIT ~ designator? }
arrayType          = { ARRAY ~ LBRACKET ~ scalarType ~ COMMA ~ expressionList ~ RBRACKET }
arrayReferenceType = { (READONLY | MUTABLE) ~ ARRAY ~ LBRACKET ~ scalarType ~ COMMA ~ (expressionList | DIM ~ EQUALS ~ expression) ~ RBRACKET }

designator = { LBRACKET ~ expression ~ RBRACKET }

defcalTarget             = { MEASURE | RESET | DELAY | Identifier }
defcalArgumentDefinition = { expression | argumentDefinition }
defcalOperand            = { HardwareQubit | Identifier }
gateOperand              = { indexedIdentifier | HardwareQubit }
externArgument           = { scalarType | arrayReferenceType | CREG ~ designator? }
argumentDefinition       = {
    scalarType ~ Identifier
  | qubitType ~ Identifier
  | (CREG | QREG) ~ Identifier ~ designator?
  | arrayReferenceType ~ Identifier
}

argumentDefinitionList       = { argumentDefinition ~ (COMMA ~ argumentDefinition)* ~ COMMA? }
defcalArgumentDefinitionList = { defcalArgumentDefinition ~ (COMMA ~ defcalArgumentDefinition)* ~ COMMA? }
defcalOperandList            = { defcalOperand ~ (COMMA ~ defcalOperand)* ~ COMMA? }
expressionList               = { expression ~ (COMMA ~ expression)* ~ COMMA? }
identifierList               = { Identifier ~ (COMMA ~ Identifier)* ~ COMMA? }
gateOperandList              = { gateOperand ~ (COMMA ~ gateOperand)* ~ COMMA? }
externArgumentList           = { externArgument ~ (COMMA ~ externArgument)* ~ COMMA? }

// lexer grammar qasm3Lexer;

/* Language keywords. */
OPENQASM = { "OPENQASM" }
// -> pushMode(VERSION_IDENTIFIER);
INCLUDE = { "include" }
// -> pushMode(ARBITRARY_STRING)
DEFCALGRAMMAR = { "defcalgrammar" }
// -> pushMode(ARBITRARY_STRING)
DEF = { "def" }
CAL = { "cal" }
// -> mode(CAL_PRELUDE);
DEFCAL = { "defcal" }
// -> mode(DEFCAL_PRELUDE);
GATE   = { "gate" }
EXTERN = { "extern" }
BOX    = { "box" }
LET    = { "let" }

BREAK    = { "break" }
CONTINUE = { "continue" }
IF       = { "if" }
ELSE     = { "else" }
END      = { "end" }
RETURN   = { "return" }
FOR      = { "for" }
WHILE    = { "while" }
IN       = { "in" }
SWITCH   = { "switch" }
CASE     = { "case" }
DEFAULT  = { "default" }

PRAGMA = { "#"? ~ "pragma" }
// -> pushMode(EAT_TO_LINE_END)
AnnotationKeyword = { "@" ~ Identifier }
// ->  pushMode(EAT_TO_LINE_END)

/* Types. */

INPUT    = { "input" }
OUTPUT   = { "output" }
CONST    = { "const" }
READONLY = { "readonly" }
MUTABLE  = { "mutable" }

QREG  = { "qreg" }
QUBIT = { "qubit" }

CREG    = { "creg" }
BOOL    = { "bool" }
BIT     = { "bit" }
INT     = { "int" }
UINT    = { "uint" }
FLOAT   = { "float" }
ANGLE   = { "angle" }
COMPLEX = { "complex" }
ARRAY   = { "array" }
VOID    = { "void" }

DURATION = { "duration" }
STRETCH  = { "stretch" }

/* Builtin identifiers and operations */

GPHASE  = { "gphase" }
INV     = { "inv" }
POW     = { "pow" }
CTRL    = { "ctrl" }
NEGCTRL = { "negctrl" }

DIM = { "#dim" }

DURATIONOF = { "durationof" }

DELAY   = { "delay" }
RESET   = { "reset" }
MEASURE = { "measure" }
BARRIER = { "barrier" }

BooleanLiteral = @{ "true" | "false" }

/* Symbols */

LBRACKET = { "[" }
RBRACKET = { "]" }
LBRACE   = { "{" }
RBRACE   = { "}" }
LPAREN   = { "(" }
RPAREN   = { ")" }

COLON     = { ":" }
SEMICOLON = { ";" }

DOT   = { "." }
COMMA = { "," }

EQUALS            = { "=" }
ARROW             = { "->" }
PLUS              = { "+" }
DOUBLE_PLUS       = { "++" }
MINUS             = { "-" }
ASTERISK          = { "*" }
DOUBLE_ASTERISK   = { "**" }
SLASH             = { "/" }
PERCENT           = { "%" }
PIPE              = { "|" }
DOUBLE_PIPE       = { "||" }
AMPERSAND         = { "&" }
DOUBLE_AMPERSAND  = { "&&" }
CARET             = { "^" }
AT                = { "@" }
TILDE             = { "~" }
EXCLAMATION_POINT = { "!" }

EqualityOperator           = { "==" | "!=" }
CompoundAssignmentOperator = { "+=" | "-=" | "*=" | "/=" | "&=" | "|=" | "~=" | "^=" | "<<=" | ">>=" | "%=" | "**=" }
ComparisonOperator         = { ">" | "<" | ">=" | "<=" }
BitshiftOperator           = { ">>" | "<<" }

IMAG             =  { "im" }
ImaginaryLiteral = @{ (DecimalIntegerLiteral | FloatLiteral) ~ (" " | "\t")* ~ IMAG }

BinaryIntegerLiteral  = @{ ("0b" | "0B") ~ (ASCII_BIN_DIGIT ~ "_"?)* ~ ASCII_BIN_DIGIT }
OctalIntegerLiteral   = @{ "0o" ~ (ASCII_OCT_DIGIT ~ "_"?)* ~ ASCII_OCT_DIGIT }
DecimalIntegerLiteral = @{ (ASCII_DIGIT ~ "_"?)* ~ ASCII_DIGIT }
HexIntegerLiteral     = @{ ("0x" | "0X") ~ (ASCII_HEX_DIGIT ~ "_"?)* ~ ASCII_HEX_DIGIT }

ValidUnicode       = _{ UPPERCASE_LETTER | LOWERCASE_LETTER | TITLECASE_LETTER | MODIFIER_LETTER | OTHER_LETTER | LETTER_NUMBER }
Letter             = _{ ASCII_ALPHA }
FirstIdCharacter   = _{ "_" | ValidUnicode | Letter }
GeneralIdCharacter = _{ FirstIdCharacter | ASCII_DIGIT }

Identifier    = @{ FirstIdCharacter ~ GeneralIdCharacter* }
QuantoVar = @{ "$" ~ Identifier }
HardwareQubit = @{ "$" ~ ASCII_DIGIT+ }

/* fragment */
FloatLiteralExponent = @{ ^"e" ~ (PLUS | MINUS)? ~ DecimalIntegerLiteral }
FloatLiteral         = @{
    DecimalIntegerLiteral ~ FloatLiteralExponent
  | DOT ~ DecimalIntegerLiteral ~ FloatLiteralExponent?
  | DecimalIntegerLiteral ~ DOT ~ DecimalIntegerLiteral? ~ FloatLiteralExponent?
}

TimeUnit = _{ "dt" | "ns" | "us" | "Âµs" | "ms" | "s" }
// represents explicit time value in SI or backend units
TimingLiteral = @{ (DecimalIntegerLiteral | FloatLiteral) ~ (" " | "\t")* ~ TimeUnit }

BitstringLiteral = @{ "\"" ~ (ASCII_BIN_DIGIT ~ "_"?)* ~ ASCII_BIN_DIGIT ~ "\"" }

// Ignore whitespace between tokens, and define C++-style comments.
Whitespace  = _{ (" " | "\t")+ }
Newline     = _{ ("\r" | "\n")+ }
WHITESPACE  = _{ Whitespace | Newline }
LineComment = _{ "//" ~ (!NEWLINE ~ ANY)* }
// FIXME: for some reason the original ANTLR grammar uses `?` instead of `*`
BlockComment = _{ "/*" ~ (!"*/" ~ ANY)? ~ "*/" }
COMMENT      = _{ LineComment | BlockComment }

// The version identifier token would be ambiguous between itself and
// integer/floating-point literals, so we use a special mode to ensure it's
// lexed correctly.
/* mode VERSION_IDENTIFIER; */
VERSION_IDENTIFER_WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }
VersionSpecifier             =  { ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
// -> popMode;

// An include statement's path or defcalgrammar target is potentially ambiguous
// with `BitstringLiteral`.
/* mode ARBITRARY_STRING; */
ARBITRARY_STRING_WHITESPACE = { (" " | "\t" | "\r" | "\n")+ }
// allow ``"str"`` and ``'str'``;
StringLiteral = {
    ("\"" ~ (!("\"" | "\r" | "\t" | "\n") ~ ANY)* ~ "\"" | "'" ~ (!("\"" | "\r" | "\t" | "\n") ~ ANY)* ~ "'")
}
// -> popMode;

// A different lexer mode to swap to when we need handle tokens on a line basis
// rather than the default arbitrary-whitespace-based tokenisation.  This is
// used by the annotation and pragma rules.
/* mode EAT_TO_LINE_END; */
EAT_INITIAL_SPACE = _{ " " | "\t" }
EAT_LINE_END      = _{ "\r" | "\n" }
// -> popMode, skip;

// The line content must be a non-empty token to satisfy ANTLR (otherwise it
// would be able to produce an infinite number of tokens).  We could include
// the line ending to guarantee that this is always non-empty, but that just
// puts an annoying burden on consumers to remove it again.
RemainingLineContent = _{ (" " | "\t" | "\r" | "\n") ~ ("\r" | "\n")* }

// We need to do a little context-aware lexing when we hit a `cal` or `defcal`
// token.  In both cases, there's a small interlude before the pulse grammar
// block starts, and we need to be able to lex our way through that.  We don't
// want to tie this grammar to one host language by injecting host code to
// manage the state of the lexer, so instead we need to do a little duplication
// of the tokens, because ANTLR doesn't allow us to inherit rules directly.
/* mode CAL_PRELUDE; */
CAL_PRELUDE_WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }
CAL_PRELUDE_COMMENT    = _{ LineComment | BlockComment }
CAL_PRELUDE_LBRACE     =  { LBRACE }
// -> type(LBRACE), mode(CAL_BLOCK);

/* mode DEFCAL_PRELUDE; */
DEFCAL_PRELUDE_WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }
DEFCAL_PRELUDE_COMMENT    =  { LineComment | BlockComment }
DEFCAL_PRELUDE_LBRACE     =  { LBRACE }
// -> type(LBRACE), mode(CAL_BLOCK);

// Duplications of valid constant expression tokens that may appear in the
// argument list.  This is an unfortunately large number of duplications.

// Types.
DEFCAL_PRELUDE_QREG = { QREG }
// -> type(QREG);
DEFCAL_PRELUDE_QUBIT = { QUBIT }
// -> type(QUBIT);
DEFCAL_PRELUDE_CREG = { CREG }
// -> type(CREG);
DEFCAL_PRELUDE_BOOL = { BOOL }
// -> type(BOOL);
DEFCAL_PRELUDE_BIT = { BIT }
// -> type(BIT);
DEFCAL_PRELUDE_INT = { INT }
// -> type(INT);
DEFCAL_PRELUDE_UINT = { UINT }
// -> type(UINT);
DEFCAL_PRELUDE_ANGLE = { ANGLE }
// -> type(ANGLE);
DEFCAL_PRELUDE_FLOAT = { FLOAT }
// -> type(FLOAT);
DEFCAL_PRELUDE_COMPLEX = { COMPLEX }
// -> type(COMPLEX);
DEFCAL_PRELUDE_ARRAY = { ARRAY }
// -> type(ARRAY);
DEFCAL_PRELUDE_DURATION = { DURATION }
// -> type(DURATION);

// Punctuation.
DEFCAL_PRELUDE_LBRACKET = { LBRACKET }
// -> type(LBRACKET);
DEFCAL_PRELUDE_RBRACKET = { RBRACKET }
// -> type(RBRACKET);
DEFCAL_PRELUDE_LPAREN = { LPAREN }
// -> type(LPAREN);
DEFCAL_PRELUDE_RPAREN = { RPAREN }
// -> type(RPAREN);
DEFCAL_PRELUDE_ARROW = { ARROW }
// -> type(ARROW);
DEFCAL_PRELUDE_COMMA = { COMMA }
// -> type(COMMA);
DEFCAL_PRELUDE_PLUS = { PLUS }
// -> type(PLUS);
DEFCAL_PRELUDE_MINUS = { MINUS }
// -> type(MINUS);
DEFCAL_PRELUDE_ASTERISK = { ASTERISK }
// -> type(ASTERISK);
DEFCAL_PRELUDE_SLASH = { SLASH }
// -> type(SLASH);
DEFCAL_PRELUDE_BitshiftOperator = { BitshiftOperator }
// -> type(BitshiftOperator);

// Literals and names.
DEFCAL_PRELUDE_BitstringLiteral = { BitstringLiteral }
// -> type(BitstringLiteral);
DEFCAL_PRELUDE_BinaryIntegerLiteral = { BinaryIntegerLiteral }
// -> type(BinaryIntegerLiteral);
DEFCAL_PRELUDE_OctalIntegerLiteral = { OctalIntegerLiteral }
// -> type(OctalIntegerLiteral);
DEFCAL_PRELUDE_DecimalIntegerLiteral = { DecimalIntegerLiteral }
// -> type(DecimalIntegerLiteral);
DEFCAL_PRELUDE_HexIntegerLiteral = { HexIntegerLiteral }
// -> type(HexIntegerLiteral);
DEFCAL_PRELUDE_FloatLiteral = { FloatLiteral }
// -> type(FloatLiteral);
DEFCAL_PRELUDE_MEASURE = { MEASURE }
// -> type(MEASURE);
DEFCAL_PRELUDE_DELAY = { DELAY }
// -> type(DELAY);
DEFCAL_PRELUDE_RESET = { RESET }
// -> type(RESET);
DEFCAL_PRELUDE_Identifier = { Identifier }
// -> type(Identifier);
DEFCAL_PRELUDE_HardwareQubit = { HardwareQubit }
// -> type(HardwareQubit);

// The meat-and-potatoes of matching a calibration block with balanced inner
// braces.  We enter `CAL_BLOCK` with the opening brace already tokenised
// (that's how the lexer knew to swap modes to us), and with the token left open
// to continue to accumulate.  We want to tokenise until we hit the balancing
// brace.  Since we have _no_ knowledge of what the inner langauge is doing,
// things like unbalanced braces in comments will cause a failure, but there's
// not much we can do about that without greater spec restrictions.
/* mode CAL_BLOCK; */
NestedCalibrationBlock = _{ LBRACE ~ (NestedCalibrationBlock | (!("{" | "}") ~ ANY))* ~ RBRACE }
CalibrationBlock       =  { (NestedCalibrationBlock | (!("{" | "}") ~ ANY))+ }
CAL_BLOCK_RBRACE       =  { RBRACE }
// -> type(RBRACE), mode(DEFAULT_MODE);
